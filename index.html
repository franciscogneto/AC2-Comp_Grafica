<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
        var coordSystem = function (b) { var g = b.normalize(); b = 0 == Math.abs(b.x) && 0 == Math.abs(b.y) ? (new BABYLON.Vector3(b.z, 0, 0)).normalize() : (new BABYLON.Vector3(b.y, -b.x, 0)).normalize(); var r = BABYLON.Vector3.Cross(b, g); return { x: b, y: g, z: r } }, randPct = function (b, g) { return 0 == g ? b : (1 + (1 - 2 * Math.random()) * g) * b }, createBranch = function (b, g, r, w, h, l, v, n, x) { for (var t = [], d, c = [], f, q = [], a = 0; 12 > a; a++)t[a] = []; for (var m = 0; m < h; m++)for (a = m / h, d = g.y.scale(a * r), d.addInPlace(g.x.scale(v * Math.exp(-a) * Math.sin(l * a * Math.PI))), d.addInPlace(b), c[m] = d, d = n * (1 + (.4 * Math.random() - .2)) * (1 - (1 - w) * a), q.push(d), a = 0; 12 > a; a++)f = a * Math.PI / 6, f = g.x.scale(d * Math.cos(f)).add(g.z.scale(d * Math.sin(f))), f.addInPlace(c[m]), t[a].push(f); for (a = 0; 12 > a; a++)t[a].push(c[c.length - 1]); return { branch: BABYLON.MeshBuilder.CreateRibbon("branch", { pathArray: t, closeArray: !0 }, x), core: c, _radii: q } }, createTreeBase = function (b, g, r, w, h, l, v, n, x, t) { var d = 2 / (1 + Math.sqrt(5)), c = new BABYLON.Vector3(0, 1, 0), f, c = coordSystem(c), q = new BABYLON.Vector3(0, 0, 0), a = [], m = [], e = [], A = [], q = createBranch(q, c, b, g, r, 1, x, 1, t); a.push(q.branch); var y = q.core; m.push(y); e.push(q._radii); A.push(c); for (var q = y[y.length - 1], y = 2 * Math.PI / h, z, u, p, C, B = 0; B < h; B++)if (f = randPct(B * y, .25), f = c.y.scale(Math.cos(randPct(l, .15))).add(c.x.scale(Math.sin(randPct(l, .15)) * Math.sin(f))).add(c.z.scale(Math.sin(randPct(l, .15)) * Math.cos(f))), z = coordSystem(f), f = createBranch(q, z, b * v, g, r, n, x * d, g, t), p = f.core, p = p[p.length - 1], a.push(f.branch), m.push(f.core), e.push(f._radii), A.push(z), 1 < w) for (var D = 0; D < h; D++)u = randPct(D * y, .25), u = z.y.scale(Math.cos(randPct(l, .15))).add(z.x.scale(Math.sin(randPct(l, .15)) * Math.sin(u))).add(z.z.scale(Math.sin(randPct(l, .15)) * Math.cos(u))), u = coordSystem(u), C = createBranch(p, u, b * v * v, g, r, n, x * d * d, g * g, t), a.push(C.branch), m.push(C.core), e.push(f._radii), A.push(u); return { tree: BABYLON.Mesh.MergeMeshes(a), paths: m, radii: e, directions: A } }, createTree = function (b, g, r, w, h, l, v, n, x, t, d, c, f, q, a, m) { 1 != h && 2 != h && (h = 1); var e = createTreeBase(b, g, r, h, l, v, n, d, c, m); e.tree.material = w; var A = b * Math.pow(n, h), y = A / (2 * f), z = 1.5 * Math.pow(g, h - 1); n = BABYLON.MeshBuilder.CreateDisc("leaf", { radius: z / 2, tessellation: 12, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, m); b = new BABYLON.SolidParticleSystem("leaveSPS", m, { updatable: !1 }); b.addShape(n, 2 * f * Math.pow(l, h), { positionFunction: function (b, a, g) { a = Math.floor(g / (2 * f)); 1 == h ? a++ : a = 2 + a % l + Math.floor(a / l) * (l + 1); var E = (g % (2 * f) * y + 3 * y / 2) / A, d = Math.ceil(r * E); d > e.paths[a].length - 1 && (d = e.paths[a].length - 1); var k = d - 1, c = k / (r - 1), m = d / (r - 1); b.position = new BABYLON.Vector3(e.paths[a][k].x + (e.paths[a][d].x - e.paths[a][k].x) * (E - c) / (m - c), e.paths[a][k].y + (e.paths[a][d].y - e.paths[a][k].y) * (E - c) / (m - c) + (.6 * z / q + e.radii[a][d]) * (g % 2 * 2 - 1), e.paths[a][k].z + (e.paths[a][d].z - e.paths[a][k].z) * (E - c) / (m - c)); b.rotation.z = Math.random() * Math.PI / 4; b.rotation.y = Math.random() * Math.PI / 2; b.rotation.z = Math.random() * Math.PI / 4; b.scale.y = 1 / q } }); b = b.buildMesh(); b.billboard = !0; n.dispose(); d = new BABYLON.SolidParticleSystem("miniSPS", m, { updatable: !1 }); n = new BABYLON.SolidParticleSystem("minileavesSPS", m, { updatable: !1 }); var u = []; c = 2 * Math.PI / l; for (var p = 0; p < Math.pow(l, h + 1); p++)u.push(randPct(Math.floor(p / Math.pow(l, h)) * c, .2)); c = function (a, b, d) { var c = d % Math.pow(l, h); 1 == h ? c++ : c = 2 + c % l + Math.floor(c / l) * (l + 1); var f = e.directions[c], c = new BABYLON.Vector3(e.paths[c][e.paths[c].length - 1].x, e.paths[c][e.paths[c].length - 1].y, e.paths[c][e.paths[c].length - 1].z), k = u[d], k = f.y.scale(Math.cos(randPct(v, 0))).add(f.x.scale(Math.sin(randPct(v, 0)) * Math.sin(k))).add(f.z.scale(Math.sin(randPct(v, 0)) * Math.cos(k))), f = BABYLON.Vector3.Cross(BABYLON.Axis.Y, k), k = Math.acos(BABYLON.Vector3.Dot(k, BABYLON.Axis.Y) / k.length()); a.scale = new BABYLON.Vector3(Math.pow(g, h + 1), Math.pow(g, h + 1), Math.pow(g, h + 1)); a.quaternion = BABYLON.Quaternion.RotationAxis(f, k); a.position = c; }; for (var C = [], B = [], p = e.paths.length, D = e.paths[0].length, F = 0; F < x; F++)C.push(2 * Math.PI * Math.random() - Math.PI), B.push([Math.floor(Math.random() * p), Math.floor(Math.random() * (D - 1) + 1)]); p = function (a, c, b) { var d = B[b][0], f = B[b][1], k = e.directions[d]; c = new BABYLON.Vector3(e.paths[d][f].x, e.paths[d][f].y, e.paths[d][f].z); c.addInPlace(k.z.scale(e.radii[d][f] / 2)); b = C[b]; k = k.y.scale(Math.cos(randPct(t, 0))).add(k.x.scale(Math.sin(randPct(t, 0)) * Math.sin(b))).add(k.z.scale(Math.sin(randPct(t, 0)) * Math.cos(b))); b = BABYLON.Vector3.Cross(BABYLON.Axis.Y, k); k = Math.acos(BABYLON.Vector3.Dot(k, BABYLON.Axis.Y) / k.length()); a.scale = new BABYLON.Vector3(Math.pow(g, h + 1), Math.pow(g, h + 1), Math.pow(g, h + 1)); a.quaternion = BABYLON.Quaternion.RotationAxis(b, k); a.position = c }; d.addShape(e.tree, Math.pow(l, h + 1), { positionFunction: c }); d.addShape(e.tree, x, { positionFunction: p }); d = d.buildMesh(); d.material = w; n.addShape(b, Math.pow(l, h + 1), { positionFunction: c }); n.addShape(b, x, { positionFunction: p }); w = n.buildMesh(); b.dispose(); w.material = a; a = BABYLON.MeshBuilder.CreateBox("", {}, m); a.isVisible = !1; e.tree.parent = a; d.parent = a; return w.parent = a };
        var camera = null;
        var inputMap = {};
        var lastMove = '';
        var interableMeshs = [];
        var barrels = [];
        var iteracao = 0;
        var createScene = function () {

            // Engine Config
            engine.enableOfflineSupport = false;

            // Scene
            scene = new BABYLON.Scene(engine);

            buildGUI();
            createApples();
            createBarrel(new BABYLON.Vector3(3, 0, 0));
            //createBarrel(new BABYLON.Vector3(6, 0, 0));
            createEnvironment();
            managerEvents();
            createHero();

            return scene;
        }



        function createEnvironment() {

            // Camera
            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(0, -5, 0), scene);
            scene.activeCamera = camera;
            scene.activeCamera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 2;
            camera.upperRadiusLimit = 100;
            camera.wheelDeltaPercentage = 0.01;

            // Lights
            var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.6;
            light.specular = BABYLON.Color3.Black();

            var light2 = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(0, -0.5, -1.0), scene);
            light2.position = new BABYLON.Vector3(0, 5, 5);

            // Skybox
            var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000.0 }, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("http://www.babylonjs-playground.com/textures/skybox4", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = BABYLON.Color3.Black()
            skyboxMaterial.specularColor = BABYLON.Color3.Black();
            skybox.material = skyboxMaterial;

            // Ground
            /*var ground = BABYLON.MeshBuilder.CreateGround("ground", { height: 50, width: 50, subdivisions: 4 }, scene);
            var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseTexture = new BABYLON.Texture("textures/wood.jpg", scene);
            groundMaterial.diffuseTexture.uScale = 30;
            groundMaterial.diffuseTexture.vScale = 30;
            groundMaterial.specularColor = new BABYLON.Color3(.1, .1, .1);
            ground.material = groundMaterial;*/

            //HighMap
            const largeGroundMaterial = new BABYLON.StandardMaterial("largeGroundMat");
            largeGroundMaterial.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/valleygrass.png");
            const largeGround = BABYLON.MeshBuilder.CreateGroundFromHeightMap("largeGround", "https://assets.babylonjs.com/environments/villageheightmap.png", { width: 150, height: 150, subdivisions: 20, minHeight: 0, maxHeight: 10 });
            largeGround.scaling = new BABYLON.Vector3(5, 5, 5);
            largeGround.material = largeGroundMaterial;


            //Tube to delimit the area
            const myPath = [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 6, 0)
            ];

            const tube = BABYLON.MeshBuilder.CreateTube("tube", { path: myPath, radius: 50, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
            tube.isVisible = true;


            //const heroTube = BABYLON.MeshBuilder.CreateTube("heroTube", { path: myPath, radius: 0.25, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);

            //tree
            var green = new BABYLON.StandardMaterial("green", scene);
            green.diffuseColor = new BABYLON.Color3(0, 1, 0);

            //trunk and branch material
            var bark = new BABYLON.StandardMaterial("bark", scene);
            bark.emissiveTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
            bark.diffuseTexture = new BABYLON.Texture("https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Bark_texture_wood.jpg/800px-Bark_texture_wood.jpg", scene);
            bark.diffuseTexture.uScale = 2.0;//Repeat 5 times on the Vertical Axes
            bark.diffuseTexture.vScale = 2.0;//Repeat 5 times on the Horizontal Axes		

            //Tree parameters			
            var trunk_height = 10;
            var trunk_taper = 0.5;
            var trunk_slices = 8;
            var boughs = 1; // 1 or 2
            var forks = 4;
            var fork_angle = Math.PI / 4;
            var fork_ratio = 2 / (1 + Math.sqrt(5)); //PHI the golden ratio
            var branch_angle = Math.PI / 3;
            var bow_freq = 2;
            var bow_height = 3.5;
            var branches = 10;
            var leaves_on_branch = 5;
            var leaf_wh_ratio = 0.5;

            var tree = createTree(trunk_height, trunk_taper, trunk_slices, bark, boughs, forks, fork_angle, fork_ratio, branches, branch_angle, bow_freq, bow_height, leaves_on_branch, leaf_wh_ratio, green, scene);
            tree.position.x += 50;
            var auxTree = tree.clone();
            auxTree.position.z += 50;

            tree.clone().position.x -= 100;
            auxTree.clone().position.x -= 100;
        }

        function buildGUI() {
            var advancedTexture;

            if (advancedTexture) {
                advancedTexture.dispose();
            }

            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            var autoresPanel = new BABYLON.GUI.StackPanel();
            autoresPanel.width = "350px"
            autoresPanel.height = "100px";
            autoresPanel.isVertical = true;
            autoresPanel.paddingBottom = "20px";
            autoresPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            autoresPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            autoresPanel.fontSize = 16;
            advancedTexture.addControl(autoresPanel);

            var comandosPanel = new BABYLON.GUI.StackPanel();
            comandosPanel.width = "155px";
            comandosPanel.isVertical = true;
            comandosPanel.paddingRight = "0px";
            comandosPanel.paddingBottom = "125px";
            comandosPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            comandosPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
            comandosPanel.fontSize = 16;
            advancedTexture.addControl(comandosPanel);

            var addHeader = function (text, panel, alinhamento) {
                var header = new BABYLON.GUI.TextBlock();
                header.text = text;
                header.height = "30px";
                header.color = "white";
                header.textHorizontalAlignment = alinhamento;

                panel.addControl(header);
            }

            var alinhamentoEsquerda = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            var alinhamentoCentro = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;

            addHeader("COMANDOS", comandosPanel, alinhamentoEsquerda);
            addHeader("- Mover: W|A|S|D", comandosPanel, alinhamentoEsquerda);
            addHeader("- Sambar: [B]", comandosPanel, alinhamentoEsquerda);
            addHeader("- Câmera: Mouse", comandosPanel, alinhamentoEsquerda);

            addHeader("AUTORES", autoresPanel, alinhamentoCentro);
            addHeader("Francisco Godinho Neto - 180141", autoresPanel, alinhamentoCentro);
            addHeader("Vinícius Cavalcante Silva Souza - 180854", autoresPanel, alinhamentoCentro);

        }

        function managerEvents() {
            // Keyboard events
            inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));


        }
        class Barrel {
            constructor(barrel, name, position) {
                //this.name = name;
                this.condition = 0;
                this.barrel = barrel;
                this.barrel.name = name;
                this.barrel.scaling.scaleInPlace(0.015);
                //const cylinder = BABYLON.MeshBuilder.CreateCylinder(name, { diameter: 0.65 }, scene);
                this.gamb = BABYLON.MeshBuilder.CreateCylinder(name, { diameter: 0.65 }, scene);
                this.gamb.position = this.barrel.position = position;

                scene.addMesh(this.barrel);
                interableMeshs.push(this.gamb);
                BABYLON.ParticleHelper.CreateAsync("smoke", scene).then((set) => {
                    this.smoke = set;
                    set.start(this.gamb.position);
                });

                // Tone mapping
                scene.imageProcessingConfiguration.toneMappingEnabled = true;
                scene.imageProcessingConfiguration.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                scene.imageProcessingConfiguration.exposure = 1;


                this.sound = new BABYLON.Sound("explosion", "sounds/explosion.wav", scene, null, { loop: false, autoplay: false });
            }

            destroy() {
                if (this.condition == 1) {



                    console.log('aaa');
                    this.barrel.dispose();
                    this.gamb.dispose();
                    scene.removeMesh(this.barrel);
                    scene.removeMesh(this.gamb);

                    //this.particleSystem.start();
                    this.sound.play();
                    var pipeline = new BABYLON.DefaultRenderingPipeline("default", true, scene);

                    // Tone mapping
                    scene.imageProcessingConfiguration.toneMappingEnabled = true;
                    scene.imageProcessingConfiguration.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
                    scene.imageProcessingConfiguration.exposure = 1;

                    // Bloom
                    pipeline.bloomEnabled = true;
                    pipeline.bloomThreshold = 0.8;
                    pipeline.bloomWeight = 1;
                    pipeline.bloomKernel = 64;
                    pipeline.bloomScale = 0.5;
                    this.condition = 2;
                    BABYLON.ParticleHelper.CreateAsync("explosion", scene).then((set) => {
                        set.systems.forEach(x => {
                            x.disposeOnStop = true;
                            x.maxSize = 0;
                            x.minSize = 0;
                        });
                        set.start(this.gamb.position);
                        this.smoke.dispose();
                    });
                }
                else if (this.condition == 0) {
                    this.condition = 1;
                }

            }


        }
        function createBarrel(position) {
            BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "ExplodingBarrel.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
                var barrel = newMeshes[0];
                //const cylinder = BABYLON.MeshBuilder.CreateCylinder("barril", { diameter: 0.65 }, scene);
                var aux = new Barrel(barrel, 'barril1', position);
                barrels.push(aux);

            });
        }
        function createHero() {







            // Load hero character
            BABYLON.SceneLoader.ImportMesh("", "https://assets.babylonjs.com/meshes/", "HVGirl.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
                var hero = newMeshes[0];
                hero.name = 'hero';
                //adicionando o hero a scena
                scene.addMesh(hero);

                //Scale the model down        
                hero.scaling.scaleInPlace(0.1);

                //Lock camera on the character 
                camera.target = hero;

                //Hero character variables 
                var heroSpeed = 0.03;
                var heroSpeedBackwards = 0.01;
                var heroRotationSpeed = 0.1;

                var animating = true;

                const walkAnim = scene.getAnimationGroupByName("Walking");
                const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
                const idleAnim = scene.getAnimationGroupByName("Idle");
                const sambaAnim = scene.getAnimationGroupByName("Samba");

                var first_position = hero.position;

                //Rendering loop (executed for everyframe)
                scene.onBeforeRenderObservable.add(() => {
                    var tube = scene.getMeshByName('tube');

                    var keydown = false;

                    var inside = isInside(hero.position, 50);
                    if (inside) {
                        if (inputMap["w"]) {
                            hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                            keydown = true;
                            lastMove = 'front';
                        }

                        if (inputMap["a"]) {
                            hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                            keydown = true;
                        }
                        if (inputMap["d"]) {
                            hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                            keydown = true;
                        }
                        if (inputMap["b"]) {
                            keydown = true;
                        }
                        if (inputMap["s"]) {
                            hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                            keydown = true;
                            lastMove = 'back';
                        }
                    } else {
                        if (lastMove == 'front') {
                            if (inputMap["s"]) {
                                hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                                keydown = true;

                            }
                        }
                        else {
                            if (inputMap["w"]) {
                                hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                                keydown = true;

                            }
                        }
                    }


                    if (keydown) {

                        if (!animating) {
                            animating = true;
                            if (inputMap["s"]) {
                                //Walk backwards
                                walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);

                            }
                            else if
                                (inputMap["b"]) {
                                //Samba!
                                sambaAnim.start(true, 1.0, sambaAnim.from, sambaAnim.to, false);
                            }
                            else {
                                //Walk
                                walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);

                            }
                        }


                    }
                    else {

                        if (animating) {
                            //Default animation is idle when no key is down     
                            idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                            //Stop all animations besides Idle Anim when no key is down
                            sambaAnim.stop();
                            walkAnim.stop();
                            walkBackAnim.stop();

                            //Ensure animation are played only once per rendering loop
                            animating = false;
                        }
                    }
                    var barril = scene.getMeshByName('barril');
                    var hero1 = scene.getMeshByName('hero');
                    interableMeshs.forEach((element) => {
                        if (element != null) {
                            if (hero.intersectsMesh(element)) {
                                barrels.forEach((barrel) => {

                                    if (barrel.barrel.name == element.name) {

                                        barrel.destroy();

                                    }
                                });
                            }
                            else {

                            }
                        }
                    });


                });
            });

            // Load Exploding Barrel
        }

        function createApples() {
            var numApples = 10;
            var initScale = 0.1;
            var incScale = 0.2;
            var posApplesX = [0, 4, 7, 8, 6, 3, 0, -6, -8, -4.5];
            var posApplesZ = [8, 6, 3, 0, -4, -7, -8, -5.5, 0, 4.5];

            for (var i = 0; i < numApples; i++) {
                var appleItem = new Apple("apple" + i, initScale += incScale, posApplesX[i], posApplesZ[i]);
            }
        }


        function isInside(position, radius) {
            return (Math.sqrt(Math.pow(position.x, 2) + Math.pow(position.z, 2)) <= radius);
        }

        class Apple {
            constructor(name, scale, posX, posZ) {
                // Load Apple
                // Using the glTF model imported from: https://www.remix3d.com/details/G009SX0N139P?section=remixes
                BABYLON.SceneLoader.ImportMesh("", "//david.blob.core.windows.net/babylonjs/", "Apple.glb", scene, function (newMeshes) {
                    var appleItem = newMeshes[0];
                    appleItem.name = name;

                    //Scale the apple model      
                    appleItem.scaling.scaleInPlace(scale);

                    //Set position
                    appleItem.position.x = posX;
                    appleItem.position.z = posZ;

                    scene.addMesh(appleItem);
                });
            }
        }



        initFunction = async function () {
            var asyncEngineCreation = async function () {
                try {
                    return createDefaultEngine();
                } catch (e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

            engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            scene = createScene();
        };
        initFunction().then(() => {
            sceneToRender = scene
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>